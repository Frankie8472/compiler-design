package cd.backend.codegen;

import static cd.Config.MAIN;
import static cd.backend.codegen.AssemblyEmitter.constant;
import static cd.backend.codegen.RegisterManager.STACK_REG;

import java.io.Writer;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import cd.Config;
import cd.Main;
import cd.ToDoException;
import cd.backend.codegen.RegisterManager.Register;
import cd.ir.Ast.BuiltInWrite;
import cd.ir.Ast.BuiltInWriteln;
import cd.ir.Ast.ClassDecl;
import cd.ir.Symbol.ClassSymbol;
import cd.ir.Symbol.MethodSymbol;

public class AstCodeGenerator {

	protected RegsNeededVisitor rnv;
	
	protected VTableVisitor vtv;
	protected ExprGenerator eg;
	protected AddressExprGenerator aeg;
	protected StmtGenerator sg;
	
	protected final Main main;
	
	protected final AssemblyEmitter emit;
	protected final RegisterManager rm = new RegisterManager();
		
	
	Map<String, VTable> vTableMap = new HashMap<String, VTable>();

	AstCodeGenerator(Main main, Writer out) {
		{
			initMethodData();
		}
		
		this.emit = new AssemblyEmitter(out);
		this.main = main;
		this.rnv = new RegsNeededVisitor();

		this.vtv = new VTableVisitor();
		this.eg = new ExprGenerator(this);
		this.aeg = new AddressExprGenerator(this);
		this.sg = new StmtGenerator(this);
	}

	protected void debug(String format, Object... args) {
		this.main.debug(format, args);
	}

	public static AstCodeGenerator createCodeGenerator(Main main, Writer out) {
		return new AstCodeGenerator(main, out);
	}
	
	protected static final String VAR_PREFIX = "var_";
	
	/**
	 * Main method. Causes us to emit x86 assembly corresponding to {@code ast}
	 * into {@code file}. Throws a {@link RuntimeException} should any I/O error
	 * occur.
	 * 
	 * <p>
	 * The generated file will be divided into two sections:
	 * <ol>
	 * <li>Prologue: Generated by {@link #emitPrefix()}. This contains any
	 * introductory declarations and the like.
	 * <li>Body: Generated by {@link ExprGenerator}. This contains the main
	 * method definitions.
	 * </ol>
	 */
	public void go(List<? extends ClassDecl> astRoots) {
		
		//Create vTables
		for (ClassDecl ast : astRoots) {
			VTable vTable = new VTable();
			vTable = vtv.visit(ast, vTable);
			vTableMap.put(ast.name, vTable);
		}
		
		// Emit some useful string constants:
		emit.emitRaw(Config.DATA_STR_SECTION);
		emit.emitLabel("STR_NL");
		emit.emitRaw(Config.DOT_STRING + " \"\\n\"");
		emit.emitLabel("STR_D");
		emit.emitRaw(Config.DOT_STRING + " \"%d\"");
		emit.emitLabel("STR_DEBUG");
		emit.emitRaw(Config.DOT_STRING + " \"\\nDebug: %d\\n\"");
		
		// Emit int section
		emit.emitRaw(Config.DATA_INT_SECTION);
		
		//this_ref
		emit.emitLabel("this_ref");
		emit.emitConstantData("0");
		emit.emitLabel("classTable");
		emit.emitConstantData("0");
		emit.emitLabel("call_label");
		emit.emitConstantData("0");
		emit.emitLabel("tempValue1");
		emit.emitConstantData("0");
		
		emit.emitRaw(Config.TEXT_SECTION);
		emit.emitRaw(".globl " + MAIN);
		
		emitProgramStartPoint(astRoots);
		
		//Generate code
		for (ClassDecl ast : astRoots) {
			sg.gen(ast);
		}
	}
	
	void emitProgramStartPoint(List<? extends ClassDecl> astRoots)
	{
		//Main function
		emit.emitLabel(MAIN);
		emit.emit("enter", "$8", "$0");
		emit.emit("and", -16, RegisterManager.STACK_REG);
		
		emitClassTable(astRoots);
		
		//Create Main object		
		VTable vTable = vTableMap.get("Main");
		if (vTable == null)
		{
			throw new ToDoException("Main missing");
		}
		
		int objectSize = (1 + vTable.fields.size() + vTable.methodSymbols.size());
		
		//malloc
		emit.emit("and", -16, RegisterManager.STACK_REG);
		emit.emit("subl", constant(2 * Config.SIZEOF_PTR), Register.ESP);
		emit.emit("pushl", constant(Config.SIZEOF_PTR));
		emit.emit("pushl", constant(objectSize));
		emit.emitRaw("call " + Config.CALLOC);
		emit.emit("addl", constant(16), Register.ESP);

		rm.getRegister(Register.EAX);
		
		//store classNumber in first 4 bytes
		emit.emitStore(constant(vTable.classNumber), 0, Register.EAX);
		
		for (MethodSymbol symbol : vTable.methodSymbols.values())
		{
			String label = symbol.methodLabel;
			int offset = symbol.offset;
			Register labelRegister = rm.getRegister();
			emit.emit("leal", label, labelRegister);
			emit.emitStore(labelRegister, offset, Register.EAX);
			rm.releaseRegister(labelRegister);
		}
		
		//store in this_ref
		emit.emit("movl", Register.EAX, "this_ref");
		
		rm.releaseRegister(Register.EAX);
		
		//Call main method
		String mainLabel = vTable.methodSymbols.get("main").methodLabel;
		emit.emitRaw("call " + mainLabel);
		
		emitMethodSuffix(true);
	}


	protected void initMethodData() {
		{
			rm.initRegisters();
		}
	}


	protected void emitMethodSuffix(boolean returnNull) {
		if (returnNull)
			emit.emit("movl", "$0", Register.EAX);
		emit.emitRaw("leave");
		emit.emitRaw("ret");
	}
	
	public void emitDebug(Register reg)
	{
		emit.emit("sub", constant(1600), STACK_REG);
		emit.emitStore(reg, 4, STACK_REG);
		emit.emitStore("$STR_DEBUG", 0, STACK_REG);
		emit.emit("call", Config.PRINTF);
		emit.emit("add", constant(1600), STACK_REG);
	}
	
	public void emitDebugAddress(Register reg)
	{
		emit.emit("sub", constant(16), STACK_REG);
		emit.emitStore("(" + reg.repr + ")", 4, STACK_REG);
		emit.emitStore("$STR_DEBUG", 0, STACK_REG);
		emit.emit("call", Config.PRINTF);
		emit.emit("add", constant(16), STACK_REG);
	}
	
	//Push register to stack
		public Register pushRegister(Register reg)
		{
			if (rm.isInUse(reg))
			{
				emit.emit("pushl", reg);
				rm.releaseRegister(reg);
				return reg;
			}
			else
			{
				return null;
			}
		}
		
		//Pop register from stack
		public void popRegister(Register reg)
		{
			if (reg != null)
			{
				rm.getRegister(reg);
				emit.emit("popl", reg);
			}
		}
		
		public void emitClassTable(List<? extends ClassDecl> astRoots)
		{
			//2* for arrayTypes, +3 for Object, int[], boolean[], Object[]; +20 just to be sure
			int spaceNeeded = (2*astRoots.size() + 4 + 20);
			
			Register classTableAddress = rm.getRegister(Register.EAX);
			
			//malloc
			emit.emit("and", -16, RegisterManager.STACK_REG);
			emit.emit("subl", constant(2 * Config.SIZEOF_PTR), Register.ESP);
			emit.emit("pushl", constant(Config.SIZEOF_PTR));
			emit.emit("pushl", constant(spaceNeeded));
			emit.emitRaw("call " + Config.CALLOC);
			emit.emit("addl", constant(16), Register.ESP);
			
			//store in classTable
			emit.emit("movl", Register.EAX, "classTable");
			
			for (ClassDecl classDecl : astRoots)
			{
				int classNumber = classDecl.sym.vTable.classNumber;
				int superClassNumber;
				if (classDecl.sym.superClass == ClassSymbol.objectType)
				{
					superClassNumber = 0;
				}
				else
				{
					superClassNumber = classDecl.sym.superClass.vTable.classNumber;
				}
				
				Register register = rm.getRegister();
				
				//Store superclass address
				emit.emit("leal", AssemblyEmitter.registerOffset(superClassNumber * Config.SIZEOF_PTR, classTableAddress), register); //superClass address
				emit.emitStore(register, classNumber * Config.SIZEOF_PTR, classTableAddress);
				
				//Store for array superClass Object
				emit.emitStore(classTableAddress, (classNumber + 1) * Config.SIZEOF_PTR, classTableAddress);
				
				rm.releaseRegister(register);
			}
			
			//int[] and boolean[]
			emit.emitStore(classTableAddress, 1 * Config.SIZEOF_PTR, classTableAddress);
			emit.emitStore(classTableAddress, 2 * Config.SIZEOF_PTR, classTableAddress);
			emit.emitStore(classTableAddress, 3 * Config.SIZEOF_PTR, classTableAddress);
			
			rm.releaseRegister(classTableAddress);
		}
}