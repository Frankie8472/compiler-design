package cd.backend.codegen;

import java.io.Writer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import cd.Config;
import cd.Main;
import cd.backend.ExitCode;
import cd.backend.codegen.RegisterManager.Register;
import cd.ir.Ast.ClassDecl;
import cd.ir.Symbol;

import static cd.Config.EXIT;
import static cd.Config.MAIN;
import static cd.backend.codegen.RegisterManager.CALLEE_SAVE;
import static cd.backend.codegen.RegisterManager.STACK_REG;

public class AstCodeGenerator {

    protected RegsNeededVisitor rnv;
    protected ParamsNeededVisitor pnv;

    protected ExprGenerator eg;
    protected StmtGenerator sg;

    protected final Main main;

    protected final AssemblyEmitter emit;
    protected final RegisterManager rm = new RegisterManager();

    protected final Map<String, MemLayout> memLayouts = new HashMap<>();
    protected final Map<String, VTable> vtables = new HashMap<>();

    AstCodeGenerator(Main main, Writer out) {
        {
            initMethodData();
        }

        this.emit = new AssemblyEmitter(out);
        this.main = main;
        this.rnv = new RegsNeededVisitor();
        this.pnv = new ParamsNeededVisitor();

        this.eg = new ExprGenerator(this);
        this.sg = new StmtGenerator(this);
    }

    protected void debug(String format, Object... args) {
        this.main.debug(format, args);
    }

    public static AstCodeGenerator createCodeGenerator(Main main, Writer out) {
        return new AstCodeGenerator(main, out);
    }

    protected static final String METHOD_PREFIX = "method_";
    protected static final String VTABLE_PREFIX = "vtable_";
    protected static final String ERROR_PREFIX = "error_";

    protected static final int MIN_NUM_PARAMS = 2;

    /**
     * Main method. Causes us to emit x86 assembly corresponding to {@code ast}
     * into {@code file}. Throws a {@link RuntimeException} should any I/O error
     * occur.
     * <p>
     * <p>
     * The generated file will be divided into two sections:
     * <ol>
     * <li>Prologue: Generated by {@link #emitPrefix()}. This contains any
     * introductory declarations and the like.
     * <li>Body: Generated by {@link ExprGenerator}. This contains the main
     * method definitions.
     * </ol>
     */
    public void go(List<ClassDecl> astRoots) {
//        List<Symbol.ClassSymbol> symbols =
        ClassDecl objClassDecl = new ClassDecl("Object", null, new ArrayList<>());
        objClassDecl.sym = Symbol.ClassSymbol.objectType;
        astRoots.add(objClassDecl);

        astRoots.stream()
                .map(decl -> decl.sym)
                .sorted((a, b) -> {
                    Symbol.ClassSymbol temp;

                    temp = a;
                    while (temp != null) {
                        if (temp == b) return 1;
                        temp = temp.superClass;
                    }

                    temp = b;
                    while (temp != null) {
                        if (temp == a) return -1;
                        temp = temp.superClass;
                    }


                    return 0;
                })
                .forEach(symbol -> {
                    VTable vTable;
                    {
                        VTable parent = (symbol.superClass != null) ? this.vtables.get(symbol.superClass.name) : null;
                        vTable = new VTable(parent, symbol);
                        this.vtables.put(symbol.name, vTable);
                    }
                    {
                        MemLayout parent = this.memLayouts.get(symbol.superClass);
                        this.memLayouts.put(symbol.name, new MemLayout(parent, vTable, symbol));
                    }
                });


        // Emit some useful string constants:
        this.emit.emitRaw(Config.DATA_STR_SECTION);
        this.emit.emitLabel("STR_NL");
        this.emit.emitRaw(Config.DOT_STRING + " \"\\n\"");
        this.emit.emitLabel("STR_D");
        this.emit.emitRaw(Config.DOT_STRING + " \"%d\"");

        // Emit a label for each variable:
        // Let the AST Visitor do the iteration for us.
        this.emit.emitRaw(Config.DATA_INT_SECTION);
        this.vtables.values().forEach(vtable -> vtable.emit(this.emit));


        // Emit the main() method:
        this.emit.emitRaw(Config.TEXT_SECTION);
        this.emit.emitRaw(".globl " + MAIN);
        this.emit.emitLabel(MAIN);

        this.emit.increaseIndent("Emitting " + MAIN);

        Symbol.ClassSymbol mainSymbol = astRoots.stream().map(decl -> decl.sym).filter(sym -> sym.name.equals("Main")).findFirst().get();

        VTable vTable = this.vtables.get(mainSymbol.name);
        MemLayout memLayout = this.memLayouts.get(mainSymbol.name);

        this.emitMethodPrefix(0, true);

        this.emit.emitStore(AssemblyEmitter.constant(memLayout.size), 4, Register.ESP);
        this.emit.emitStore(AssemblyEmitter.constant(1), 0, Register.ESP);
        this.emit.emit("call", Config.CALLOC);

        this.emit.emitStore(AssemblyEmitter.labelAddress(vTable.getLabel()), 0, Register.EAX); // Store vtable address

        this.emit.emitStore(Register.EAX, 0, Register.ESP); // Store Main pointer as argument
        this.emit.emitMove(AssemblyEmitter.registerOffset(0, Register.EAX), Register.EAX); // Dereference pointer
        this.emit.emitMove(AssemblyEmitter.registerOffset(vTable.getOffset("main"), Register.EAX), Register.EAX); // Dereference main address
        this.emit.emit("call", "*" + Register.EAX); // call Main.main()

        this.emitMethodSuffix(true, null);

        this.emit.decreaseIndent();

        // Emit error calls
        this.emitErrors();

        // Emit methods
        for (ClassDecl ast : astRoots) {
            sg.visit(ast, null);
        }
    }


    protected void initMethodData() {
        rm.initRegisters();
    }

    protected void emitErrors() {
        for (ExitCode e : ExitCode.values()) {
            this.emit.emitLabel(ERROR_PREFIX + e.value);
            this.emit.increaseIndent("Emitting error " + e.value);

            this.emit.emitStore(AssemblyEmitter.constant(e.value), 0, Register.ESP);
            this.emit.emit("call", Config.EXIT);

            this.emit.decreaseIndent();
        }
    }


    protected void emitMethodPrefix(int bytes, boolean alignStack) {

        this.emit.emit("enter", AssemblyEmitter.constant(bytes), AssemblyEmitter.constant(0));
        if (alignStack)
            this.emit.emit("and", -16, STACK_REG);

        for (int i = Config.SIZEOF_PTR; i < bytes; i += Config.SIZEOF_PTR) {
            this.emit.emitStore(AssemblyEmitter.constant(0), -i, Register.EBP);
        }

        for (int i = 0; i < RegisterManager.CALLEE_SAVE.length; i++) {
            this.emit.emitStore(RegisterManager.CALLEE_SAVE[i], -(i + 1) * Config.SIZEOF_PTR, Register.EBP);
        }
    }

    protected void emitMethodSuffix(boolean returnNull, String returnLabel) {
        if (returnLabel != null)
            this.emit.emitLabel(returnLabel);

        for (int i = RegisterManager.CALLEE_SAVE.length - 1; i >= 0; i--) {
            this.emit.emitLoad(-(i + 1) * Config.SIZEOF_PTR, Register.EBP, RegisterManager.CALLEE_SAVE[i]);
        }

        if (returnNull)
            emit.emit("movl", "$0", Register.EAX);

        emit.emitRaw("leave");
        emit.emitRaw("ret");
    }

    protected int emitCallerSave(int offset, Register reg) {
        for (int i = 0; i < RegisterManager.CALLER_SAVE.length; i++) {
            if (RegisterManager.CALLER_SAVE[i] == reg) continue;
            this.emit.emitStore(RegisterManager.CALLER_SAVE[i], offset, Register.ESP);
            offset += Config.SIZEOF_PTR;
        }

        return offset;
    }

    protected void emitCallerLoad(int offset, Register reg) {
        for (int i = RegisterManager.CALLER_SAVE.length - 1; i >= 0; i--) {
            if (RegisterManager.CALLER_SAVE[i] == reg) continue;
            offset -= Config.SIZEOF_PTR;
            this.emit.emitLoad(offset, Register.ESP, RegisterManager.CALLER_SAVE[i]);
        }
    }

    protected void checkDowncast(Symbol.ClassSymbol symbol, Register pointer) {
        this.emit.emitComment("Checking Downcast");
        String nullLabel = this.emit.uniqueLabel();
        int offset = this.vtables.get(symbol.name).getParentSize();
        this.emit.emit("test", pointer, pointer);
        this.emit.emit("jz", nullLabel);
        this.emit.emit("push", pointer);
        this.emit.emitLoad(0, pointer, pointer);
        this.emit.emit("cmpl", AssemblyEmitter.labelAddress(VTABLE_PREFIX + symbol.name), AssemblyEmitter.registerOffset(offset, pointer));
        this.emit.emit("pop", pointer);
        this.emit.emit("jne", ERROR_PREFIX + ExitCode.INVALID_DOWNCAST.value);
        this.emit.emitLabel(nullLabel);
    }

    protected void checkArrayBounds(Register pointer, Register index) {
        this.emit.emitComment("Checking Array Bounds");

        // Check bounds
        this.emit.emit("test", index, index);
        this.emit.emit("js", ERROR_PREFIX + ExitCode.INVALID_ARRAY_BOUNDS.value);
        this.emit.emit("cmpl", AssemblyEmitter.registerOffset(-Config.SIZEOF_PTR, pointer), index);
        this.emit.emit("jge", ERROR_PREFIX + ExitCode.INVALID_ARRAY_BOUNDS.value);
    }

    protected void checkNullPointer(Register reg) {
        this.emit.emitComment("Checking Null Pointer");
        this.emit.emit("test", reg, reg);
        this.emit.emit("jz", ERROR_PREFIX + ExitCode.NULL_POINTER.value);
    }

    protected void checkArraySize(Register size) {
        this.emit.emitComment("Checking Array Size");
        this.emit.emit("test", size, size);
        this.emit.emit("js", ERROR_PREFIX + ExitCode.INVALID_ARRAY_SIZE.value);
    }

    protected void checkDivisionByZero(Register divisor) {
        this.emit.emitComment("Checking Division By Zero");
        this.emit.emit("test", divisor, divisor);
        this.emit.emit("jz", ERROR_PREFIX + ExitCode.DIVISION_BY_ZERO.value);
    }

    protected int getSize(Symbol.TypeSymbol symbol) {
        return (symbol instanceof Symbol.ClassSymbol) ? this.memLayouts.get(symbol.name).size : Config.SIZEOF_PTR;
    }

}