package cd.backend.codegen;

import java.io.Writer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import cd.Config;
import cd.Main;
import cd.backend.codegen.RegisterManager.Register;
import cd.ir.Ast.ClassDecl;
import cd.ir.Symbol;
import cd.ir.Symbol.ClassSymbol;
import cd.ir.Symbol.PrimitiveTypeSymbol;
import cd.ir.Symbol.TypeSymbol;
import cd.ir.Symbol.VariableSymbol;

public class AstCodeGenerator {

	protected RegsNeededVisitor rnv;
	
	protected ExprGenerator eg;
	protected StmtGenerator sg;
	
	protected final Main main;
	
	protected final AssemblyEmitter emit;
	protected final RegisterManager rm = new RegisterManager();
	
	public Map<String,VTable> vtables;
	
	//These variables keep track in which method/class we are
	public String currentLabel;
	public Symbol currentSymbol;
	public Symbol currentClass;
	//For every method there is a table from which we can read the offsets of local variables
	public Map<String,ArrayList<VariableSymbol>> localTables;
	

	AstCodeGenerator(Main main, Writer out) {
		{
			initMethodData();
		}
		
		this.emit = new AssemblyEmitter(out);
		this.main = main;
		this.rnv = new RegsNeededVisitor();

		this.eg = new ExprGenerator(this);
		this.sg = new StmtGenerator(this);
		
	}

	protected void debug(String format, Object... args) {
		this.main.debug(format, args);
	}

	public static AstCodeGenerator createCodeGenerator(Main main, Writer out) {
		return new AstCodeGenerator(main, out);
	}
	
	protected static final String VAR_PREFIX = "var_";
	protected static final String VTABLE_PREFIX ="vtable_";
	
	/**
	 * Main method. Causes us to emit x86 assembly corresponding to {@code ast}
	 * into {@code file}. Throws a {@link RuntimeException} should any I/O error
	 * occur.
	 * 
	 * <p>
	 * The generated file will be divided into two sections:
	 * <ol>
	 * <li>Prologue: Generated by {@link #emitPrefix()}. This contains any
	 * introductory declarations and the like.
	 * <li>Body: Generated by {@link ExprGenerator}. This contains the main
	 * method definitions.
	 * </ol>
	 */
	public void go(List<? extends ClassDecl> astRoots) {
		
		
		VTableCreator creator=new VTableCreator((List<ClassDecl>) astRoots);
		localTables=new HashMap<String,ArrayList<VariableSymbol>>();
		vtables=creator.initVTables();
		
		emitPrefix();
		
		for (ClassDecl ast : astRoots) {
			sg.gen(ast);
		}
		
		emitSuffix();
	}


	protected void initMethodData() {
		{
			rm.initRegisters();
		}
	}


	protected void emitMethodSuffix(boolean returnNull) {
		if (returnNull)
			emit.emit("movl", "$0", Register.EAX);
		
		for(int i=RegisterManager.CALLEE_SAVE.length-1;i>=0;i--) {
			emit.emit("popl", RegisterManager.CALLEE_SAVE[i]);
		}
		
		emit.emitRaw("leave");
		emit.emitRaw("ret");
	}
	
	public void emitPrefix() {
		
		
		// Emit some useful string constants:
		emit.emitRaw(Config.DATA_STR_SECTION);
		emit.emitLabel("STR_NL");
		emit.emitRaw(Config.DOT_STRING + " \"\\n\"");
		emit.emitLabel("STR_D");
		emit.emitRaw(Config.DOT_STRING + " \"%d\"");
		
		//Emit label for every vtable;
		emit.emitRaw(Config.DATA_INT_SECTION);
		for(VTable vtable:vtables.values()) {
			emit.emitLabel(VTABLE_PREFIX+vtable.typeSymbol);
			emit.emitConstantData("0");
		}
		
		emit.emitRaw(Config.TEXT_SECTION);
		
		//Starting point of the program
		
		emit.emitRaw(".globl " +Config.MAIN );
		emit.emitLabel(Config.MAIN);
		
		emit.emit("pushl",Register.EBP);
		emit.emitMove(Register.ESP, Register.EBP);
		
		for(VTable vtable:vtables.values()) {
			/*Put vtable on stack:
			 * id
			 * parent pointer
			 * isArray
			 * methods
			 */
			emit.increaseIndent("Emitting "+vtable.typeSymbol+" vtable");
			emit.emit("pushl", vtable.id);
			emit.emitMove(Register.ESP, VTABLE_PREFIX+vtable.typeSymbol);

			
			emit.emit("pushl",AssemblyEmitter.constant(0));
		
			if(vtable.isArray)
				emit.emit("pushl", AssemblyEmitter.constant(1));
			else
				emit.emit("pushl", AssemblyEmitter.constant(0));
			
			for(int i=0;i<vtable.methods.size();i++) {
				emit.emit("pushl", "$"+vtable.labels.get(i));
			}
			
	
			
			emit.decreaseIndent();
		}
		
		//Fill in the parent vtable pointer in each vtable
		for(VTable vt:vtables.values()) {
			emit.increaseIndent("Emitting "+vt.typeSymbol+" vtable'parent");

			if(!VTableCreator.noParent.contains(vt)) {
				 String parent=vt.parent.typeSymbol;
				 emit.emitMove(VTABLE_PREFIX+vt.typeSymbol, Register.EAX);
				 emit.emitMove(VTABLE_PREFIX+parent, Register.EBX);
				 emit.emitStore(Register.EBX, -4,Register.EAX);
			}
			emit.decreaseIndent();
		}
		
		/*
		 * Create instance of main
		 * and call main function of program
		 */
		int size = vtables.get("Main").instanceSize();
		
		emit.emit("pushl", AssemblyEmitter.constant(size));
		emit.emit("pushl", AssemblyEmitter.constant(1));
		emit.emit("call", Config.CALLOC);
		
		emit.emitMove(AstCodeGenerator.VTABLE_PREFIX+"Main", Register.EBX);
		emit.emitStore(Register.EBX, 0, Register.EAX);
		emit.emit("pushl", Register.EAX);
		
		emit.emit("call", "_Main_main");
		
		emitMethodSuffix(true);

		
	}
	
	public void emitSuffix(){
		//Some helper functions
		
		emit.emitLabel("_exit1");
		emit.emit("pushl",AssemblyEmitter.constant(1));
		emit.emit("call",Config.EXIT);
		
		emit.emitLabel("_exit3");
		emit.emit("pushl",AssemblyEmitter.constant(3));
		emit.emit("call",Config.EXIT);
		
		emit.emitLabel("_exit4");
		emit.emit("pushl",AssemblyEmitter.constant(4));
		emit.emit("call",Config.EXIT);
		
		emit.emitLabel("_exit5");
		emit.emit("pushl",AssemblyEmitter.constant(5));
		emit.emit("call",Config.EXIT);
		
		emit.emitLabel("_exit7");
		emit.emit("pushl",AssemblyEmitter.constant(7));
		emit.emit("call",Config.EXIT);
		
		
		//Checks if one type is subtype of the other
		emit.emitLabel("_isSubtype");
		int objectId=vtables.get(ClassSymbol.objectType.name).id;
		
		emit.emit("pushl", Register.EBP);
		emit.emitMove(Register.ESP,Register.EBP);

		//eax contains vtable pointer
		//ecx contains id of type
		emit.emitLoad(12, Register.EBP, Register.EAX);
		emit.emitLoad(8, Register.EBP, Register.ECX);
		
		emit.emitMove(AssemblyEmitter.constant(objectId),Register.EDX);
		
		emit.emitLabel("check");
		
		emit.emit("pushl", Register.EAX);
		emit.emitLoad(0, Register.EAX, Register.EAX);
		
		emit.emit("cmp", Register.EAX,Register.EDX);
		emit.emit("je", "false");
		emit.emit("cmp", Register.EAX,Register.ECX);
		emit.emit("je", "true");
		
		emit.emit("popl", Register.EAX);
		emit.emitLoad(-4, Register.EAX, Register.EAX);
		emit.emit("jmp", "check");
				
		emit.emitLabel("true");
		emit.emitMove("$1", Register.EAX);
		emit.emitMove(Register.EBP, Register.ESP);
		emit.emit("popl", Register.EBP);
		emit.emitRaw("ret");
		
		emit.emitLabel("false");
		emit.emitMove("$0", Register.EAX);
		emit.emitMove(Register.EBP, Register.ESP);
		emit.emit("popl", Register.EBP);
		emit.emitRaw("ret");
		
		
		
	}
	
	
}